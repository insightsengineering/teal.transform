---
title: "Data Extract"
author: "NEST CoreDev"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data Extract}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r setup, include = FALSE, echo=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

There are times when an app developer wants to offer users more flexibility in analyzing data within their custom module. 
In such cases, relinquishing control of the application to users requires developers to provide a degree of freedom. 
With `teal`, app developers can open up their applications to users, allowing them to decide exactly which app data to 
analyze within the module.

Many `teal` modules leverage `data_extract_spec` objects and modules to handle user input. Examples can be found in `teal.modules.general` and `teal.modules.clinical`.

### `data_extract_spec`

The role of `data_extract_spec` is twofold: to create a UI component in a `shiny` application and to pass user input 
from the UI to the module itself. Let's delve into how it fulfills both these responsibilities.

#### Example module

To demonstrate different initialization options of `data_extract_spec`, let's first define a `shiny` module that
utilizes `data_extract_ui` and `data_extract_srv` to handle `data_extract_spec` objects. This module creates a UI 
component for a single `data_extract_spec` and prints a list of values returned from the `data_extract_srv` module. 
For more information about `data_extract_ui` and `data_extract_srv`, please refer to the package documentation.

```{r}
library(teal.transform)
library(teal.widgets)
library(teal.data)
library(shiny)

extract_ui <- function(id, data_extract) {
  ns <- NS(id)
  standard_layout(
    output = white_small_well(verbatimTextOutput(ns("output"))),
    encoding = data_extract_ui(ns("data_extract"), label = "variable", data_extract)
  )
}

extract_srv <- function(id, datasets, data_extract, join_keys) {
  moduleServer(id, function(input, output, session) {
    reactive_extract_input <- data_extract_srv("data_extract", datasets, data_extract, join_keys)
    s <- reactive({
      format_data_extract(reactive_extract_input())
    })
    output$output <- renderPrint({
      cat(s())
    })
  })
}
```


#### Example data

The `data_extract_srv` module depends on a list of reactive or non-reactive `data.frame` objects. 
Here, we demonstrate the usage of a list of reactive `data.frame` objects as input to `datasets`, 
along with a list of necessary join keys per `data.frame` object:

```{r}
# Define data.frame objects
ADSL <- rADSL # nolint
ADTTE <- rADTTE # nolint

# create a list of reactive data.frame objects
datasets <- list(
  ADSL = reactive(ADSL),
  ADTTE = reactive(ADTTE)
)
# create join_keys
join_keys <- join_keys(
  join_key("ADSL", "ADSL", c("STUDYID", "USUBJID")),
  join_key("ADSL", "ADTTE", c("STUDYID", "USUBJID")),
  join_key("ADTTE", "ADTTE", c("STUDYID", "USUBJID", "PARAMCD"))
)
```

Consider the following example, where we create two UI elements, one to filter on a specific level from `SEX` variable,
and a second one to select a variable from `c("BMRKR1", "AGE")`. `data_extract_spec` object is handed over to the `shiny`
app and gives instructions to generate UI components.

```{r}
simple_des <- data_extract_spec(
  dataname = "ADSL",
  filter = filter_spec(vars = "SEX", choices = c("F", "M")),
  select = select_spec(choices = c("BMRKR1", "AGE"))
)
```

#### Shiny app

Finally, we include `extract_ui` in the UI of the `shinyApp`, and utilize `extract_srv` in the server function of the `shinyApp`:

```{r eval=FALSE}
shinyApp(
  ui = fluidPage(extract_ui("data_extract", simple_des)),
  server = function(input, output, session) {
    extract_srv("data_extract", datasets, simple_des, join_keys)
  }
)
```
