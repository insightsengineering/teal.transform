check_data_extract_spec <- function(data_extract_spec) {
  if (is.null(data_extract_spec)) {
    return()
  }
  checkmate::assert_list(data_extract_spec, types = "data_extract_spec")
}

id_for_dataset <- function(dataname) {
  paste0("dataset_", dataname, "_singleextract")
}

#'
#' Creates a panel that displays (with filter and column selection)
#' conditionally on `input[ns("dataset")] == dataname`.
#'
#' @param ns (`function`) the shiny namespace function
#' @param single_data_extract_spec (`data_extract_spec`) the specification
#'   for extraction of data during the application initialization.
#'   Generated by [data_extract_spec()].
#'
#' @return (`shiny.tag`) the Shiny tag with the HTML code for the panel
#' @keywords internal
#' @examples
#' teal.transform:::cond_data_extract_single_ui(
#'   shiny::NS("TEST"),
#'   data_extract_spec(dataname = "test")
#' )
cond_data_extract_single_ui <- function(ns, single_data_extract_spec) {
  dataname <- single_data_extract_spec$dataname
  conditionalPanel(
    condition = paste0("input['", ns("dataset"), "'] == '", dataname, "'"),
    data_extract_single_ui(
      id = ns(id_for_dataset(dataname)),
      single_data_extract_spec = single_data_extract_spec
    )
  )
}

#' teal data extraction module user-interface
#'
#' @description `r lifecycle::badge("experimental")`
#' This functionality should be used in the encoding panel of your `teal` app. It will
#' allow app-developers to specify a [data_extract_spec] object. This object should be used
#' to teal module variables being filtered data from `CDISC` datasets. You can use this function in the same way as any
#' [shiny module](https://shiny.rstudio.com/articles/modules.html) UI. The corresponding server module
#' can be found in [data_extract_srv()].
#'
#' @param id (`character`) shiny input unique identifier
#' @param label (`character`) Label above the data extract input
#' @param data_extract_spec (`list` of `data_extract_spec`)
#'  This is the outcome of listing [data_extract_spec]
#'  constructor calls.
#' @param is_single_dataset (`logical`) FALSE to display the dataset widget
#'
#' @return shiny [shiny::selectInput]`s` that allow to define how to extract data from
#' a specific dataset. The input elements will be returned inside a [shiny::div] container.
#'
#' There are three inputs that will be rendered
#' \enumerate{
#'  \item{Dataset select}{ Optional. If more than one [data_extract_spec] is handed over
#'   to the function, a shiny [shiny::selectInput] will be rendered. Else just the name
#'   of the dataset is given.
#'  }
#'  \item{Filter Panel }{Optional. If the [data_extract_spec] contains a
#'   filter element a shiny [shiny::selectInput] will be rendered with the options to
#'   filter the dataset.
#'  }
#'  \item{Select panel }{A shiny [shiny::selectInput] to select columns from the dataset to
#'   go into the analysis.
#'   }
#' }
#'
#' The output can be analyzed using `data_extract_srv(...)`.
#'
#' @section UI examples:
#' \describe{
#'   \preformatted{
#' adtte_filters <- filter_spec(
#'   vars = c("PARAMCD", "CNSR"),
#'   sep = "-",
#'   choices = c("OS-1" = "OS-1", "OS-0" = "OS-0", "PFS-1" = "PFS-1"),
#'   selected = "OS-1",
#'   multiple = FALSE,
#'   label = "Choose endpoint and Censor"
#' )
#'
#' response_spec <- data_extract_spec(
#'   dataname = "ADTTE",
#'   filter = adtte_filters,
#'   select = select_spec(
#'     choices = c("AVAL", "BMRKR1", "AGE"),
#'         selected = c("AVAL", "BMRKR1"),
#'         multiple = TRUE,
#'         fixed = FALSE,
#'         label = "Column"
#'     )
#' )
#' # Call to use inside your teal module UI function
#' teal.widgets::standard_layout(
#'   encoding = div(
#'     data_extract_ui(id = "regressor", label = "Regressor Variable", data_extract_spec = response_spec)
#'   )
#' )
#'     }
#'     \if{html}{
#'       \figure{data_extract_spec_13.png}{options: alt="Dataset with multiple filters and column selection"}
#'     }
#'     \if{html}{
#'       \figure{data_extract_spec_12.png}{options: alt="Dataset with multiple filters and column selection"}
#'     }
#'     \if{html}{
#'       \figure{data_extract_spec_11.png}{options: alt="Dataset with multiple filters and column selection"}
#'     }
#' }
#'
#' @export
data_extract_ui <- function(id, label, data_extract_spec, is_single_dataset = FALSE) {
  ns <- NS(id)

  if (inherits(data_extract_spec, "data_extract_spec")) {
    data_extract_spec <- list(data_extract_spec)
  }
  check_data_extract_spec(data_extract_spec)

  if (is.null(data_extract_spec)) {
    return(helpText(sprintf("Data extraction with label '%s' is NULL. Please contact the app author.", label)))
  }
  stopifnot(
    `more than one dataset in data_extract_spec but is_single_dataset parameter is set to TRUE` =
      !is_single_dataset || length(data_extract_spec) == 1
  )

  dataset_names <- vapply(
    data_extract_spec,
    function(x) x$dataname,
    character(1),
    USE.NAMES = FALSE
  )

  stopifnot(`list contains data_extract_spec objects with the same dataset` = all(!duplicated(dataset_names)))

  dataset_input <- if (is_single_dataset) {
    NULL
  } else {
    if (length(dataset_names) == 1) {
      if ((is.null(data_extract_spec[[1]]$filter)) &&
        (
          !is.null(data_extract_spec[[1]]$select$fixed) &&
            data_extract_spec[[1]]$select$fixed == TRUE
        )) {
        NULL
      } else {
        helpText("Dataset:", tags$code(dataset_names))
      }
    } else {
      teal.widgets::optionalSelectInput(
        inputId = ns("dataset"),
        label = "Dataset",
        choices = dataset_names,
        selected = dataset_names[1],
        multiple = FALSE
      )
    }
  }
  tagList(
    include_css_files(pattern = "data_extract"),
    div(
      class = "data-extract",
      tags$label(label),
      dataset_input,
      if (length(dataset_names) == 1) {
        data_extract_single_ui(
          id = ns(id_for_dataset(dataset_names)),
          single_data_extract_spec = data_extract_spec[[1]]
        )
      } else {
        do.call(
          div,
          unname(lapply(
            data_extract_spec,
            function(x) {
              cond_data_extract_single_ui(ns, x)
            }
          ))
        )
      }
    )
  )
}

#' Function to check data_extract_specs
#'
#' Checks if dataname argument exists as a dataset.
#' Checks if selected or filter columns exist within the datasets. Throws a `shiny`
#' validation error if the above requirements are not met.
#'
#' @param datasets (`FilteredData`) the object created using the `teal` API
#' @param data_extract (`list`) the output of the `data_extract` module
#'
#' @return `NULL`
#' @keywords internal
check_data_extract_spec_react <- function(datasets, data_extract) {
  if (!all(unlist(lapply(data_extract, `[[`, "dataname")) %in% datasets$datanames())) {
    shiny::validate(
      "Error in data_extract_spec setup:\
        Data extract spec contains datasets that were not handed over to the teal app."
    )
  }

  column_return <- unlist(lapply(
    data_extract,
    function(data_extract_spec) {
      columns_filter <- if (is.null(data_extract_spec$filter)) {
        NULL
      } else {
        unique(unlist(lapply(
          data_extract_spec$filter,
          function(x) {
            if (inherits(x, "filter_spec")) {
              x$vars_choices
            } else {
              stop("Unsupported object class")
            }
          }
        )))
      }

      columns_ds <- unique(c(
        data_extract_spec$select$choices,
        columns_filter
      ))

      if (!all(columns_ds %in% names(datasets$get_data(data_extract_spec$dataname, filtered = FALSE)))) {
        non_columns <- columns_ds[!columns_ds %in% names(
          datasets$get_data(data_extract_spec$dataname, filtered = FALSE)
        )]
        paste0(
          "Error in data_extract_spec setup: ",
          "Column '",
          non_columns,
          "' is not inside dataset '",
          data_extract_spec$dataname, "'."
        )
      }
    }
  ))

  if (!is.null(column_return)) shiny::validate(unlist(column_return))
  NULL
}

#' Extraction of the selector(s) details
#'
#' @description `r lifecycle::badge("stable")`
#' Extracting details of the selection(s) in [data_extract_ui] elements.
#'
#' @inheritParams shiny::moduleServer
#' @param datasets (`FilteredData` or `list` of `reactive` or non-`reactive` `data.frame`)\cr
#'  object containing data either in the form of [teal.slice::FilteredData] or as a list of `data.frame`.
#'  When passing a list of non-reactive `data.frame` objects, they are converted to reactive `data.frame`s internally.
#'  When passing a list of reactive or non-reactive `data.frame` objects, the argument `join_keys` is required also.
#' @param data_extract_spec (`data_extract_spec` or a list of `data_extract_spec`)\cr
#'  A list of data filter and select information constructed by [data_extract_spec].
#' @param ...
#' an additional argument `join_keys` is required when `datasets` is a list of `data.frame`.
#' It shall contain the keys per dataset in `datasets`.
#'
#' @return
#' A reactive `list` containing following fields:
#'
#' \itemize{
#'   \item{`filters`: }{A list with the information on the filters that are applied to the data set.}
#'   \item{`select`: }{The variables that are selected from the dataset.}
#'   \item{`always_selected`: }{The column names from the data set that should always be selected.}
#'   \item{`reshape`: }{Whether reshape long to wide should be applied or not.}
#'   \item{`dataname`: }{The name of the data set.}
#'   \item{`internal_id`: }{The `id` of the corresponding shiny input element.}
#'   \item{`keys`: }{The names of the columns that can be used to merge the data set.}
#' }
#'
#' @references [data_extract_srv]
#'
#' @export
#'
#' @examples
#'
#' library(shiny)
#'
#' ADSL <- data.frame(
#'   STUDYID = "A",
#'   USUBJID = LETTERS[1:10],
#'   SEX = rep(c("F", "M"), 5),
#'   AGE = rpois(10, 30),
#'   BMRKR1 = rlnorm(10)
#' )
#'
#' adsl_extract <- data_extract_spec(
#'   dataname = "ADSL",
#'   filter = filter_spec(vars = "SEX", choices = c("F", "M"), selected = "F"),
#'   select = select_spec(
#'     label = "Select variable:",
#'     choices = variable_choices(ADSL, c("AGE", "BMRKR1")),
#'     selected = "AGE",
#'     multiple = TRUE,
#'     fixed = FALSE
#'   )
#' )
#'
#' # Using FilteredData
#' datasets <- teal.slice::init_filtered_data(
#'   list(ADSL = list(dataset = ADSL, keys = c("STUDYID", "USUBJID"), parent = character(0))),
#'   join_keys = teal.data::join_keys(
#'     teal.data::join_key("ADSL", "ADSL", c("USUBJID", "STUDYID"))
#'   ),
#'   cdisc = TRUE
#' )
#'
#' app <- shinyApp(
#'   ui = fluidPage(
#'     teal.widgets::standard_layout(
#'       output = verbatimTextOutput("out1"),
#'       encoding = tagList(
#'         data_extract_ui(
#'           id = "adsl_var",
#'           label = "ADSL selection",
#'           data_extract_spec = adsl_extract
#'         )
#'       )
#'     )
#'   ),
#'   server = function(input, output, session) {
#'     adsl_reactive_input <- data_extract_srv(
#'       id = "adsl_var",
#'       datasets = datasets,
#'       data_extract_spec = adsl_extract
#'     )
#'
#'     output$out1 <- renderPrint(adsl_reactive_input())
#'   }
#' )
#' \dontrun{
#' runApp(app)
#' }
#'
#' # Using reactive list of data.frames
#' data_list <- list(ADSL = reactive(ADSL))
#'
#' join_keys <- teal.data::join_keys(teal.data::join_key("ADSL", "ADSL", c("STUDYID", "USUBJID")))
#'
#' app <- shinyApp(
#'   ui = fluidPage(
#'     teal.widgets::standard_layout(
#'       output = verbatimTextOutput("out1"),
#'       encoding = tagList(
#'         data_extract_ui(
#'           id = "adsl_var",
#'           label = "ADSL selection",
#'           data_extract_spec = adsl_extract
#'         )
#'       )
#'     )
#'   ),
#'   server = function(input, output, session) {
#'     adsl_reactive_input <- data_extract_srv(
#'       id = "adsl_var",
#'       datasets = data_list,
#'       data_extract_spec = adsl_extract,
#'       join_keys = join_keys
#'     )
#'     output$out1 <- renderPrint(adsl_reactive_input())
#'   }
#' )
#' \dontrun{
#' runApp(app)
#' }
#'
data_extract_srv <- function(id, datasets, data_extract_spec, ...) {
  checkmate::assert_multi_class(datasets, c("FilteredData", "list"))
  checkmate::assert(
    checkmate::check_class(data_extract_spec, "data_extract_spec"),
    checkmate::check_list(data_extract_spec, "data_extract_spec")
  )
  UseMethod("data_extract_srv", datasets)
}

#' @rdname data_extract_srv
#' @export
data_extract_srv.FilteredData <- function(id, datasets, data_extract_spec, ...) {
  checkmate::assert_class(datasets, "FilteredData")
  moduleServer(
    id,
    function(input, output, session) {
      logger::log_trace(
        "data_extract_srv.FilteredData initialized with datasets: { paste(datasets$datanames(), collapse = ', ') }."
      )

      data_list <- sapply(X = datasets$datanames(), simplify = FALSE, FUN = function(x) {
        reactive(datasets$get_data(dataname = x, filtered = TRUE))
      })

      join_keys <- datasets$get_join_keys()

      filter_and_select_reactive <- data_extract_srv(
        id = NULL,
        datasets = data_list,
        data_extract_spec = data_extract_spec,
        join_keys = join_keys
      )
      filter_and_select_reactive
    }
  )
}

#' @rdname data_extract_srv
#' @param join_keys (`JoinKeys` or `NULL`) of keys per dataset in `datasets`
#' @export
data_extract_srv.list <- function(id, datasets, data_extract_spec, join_keys = NULL, ...) {
  checkmate::assert_list(datasets, types = c("reactive", "data.frame"), names = "named")
  checkmate::assert_class(join_keys, "JoinKeys", null.ok = TRUE)

  moduleServer(
    id,
    function(input, output, session) {
      logger::log_trace(
        "data_extract_srv.list initialized with datasets: { paste(names(datasets), collapse = ', ') }."
      )

      # get keys out of join_keys
      if (!is.null(join_keys)) {
        keys <- sapply(names(datasets), simplify = FALSE, function(x) join_keys$get(x, x))
      } else {
        keys <- sapply(names(datasets), simplify = FALSE, function(x) character(0))
      }

      # convert to list of reactives
      datasets <- sapply(X = datasets, simplify = FALSE, FUN = function(x) {
        if (is.reactive(x)) x else reactive(x)
      })

      if (inherits(data_extract_spec, "data_extract_spec")) {
        data_extract_spec <- list(data_extract_spec)
      }

      for (idx in seq_along(data_extract_spec)) {
        if (inherits(data_extract_spec[[idx]]$filter, "filter_spec")) {
          data_extract_spec[[idx]]$filter <- list(data_extract_spec[[idx]]$filter)
        }
      }

      if (is.null(data_extract_spec)) {
        return(reactive(NULL))
      }
      check_data_extract_spec(data_extract_spec = data_extract_spec)

      filter_and_select <- lapply(data_extract_spec, function(x) {
        data_extract_single_srv(
          id = id_for_dataset(x$dataname),
          datasets = datasets,
          single_data_extract_spec = x
        )

        data_extract_read_srv(
          id = id_for_dataset(x$dataname),
          datasets = datasets,
          single_data_extract_spec = x
        )
      })
      names(filter_and_select) <- sapply(data_extract_spec, function(x) x$dataname)

      dataname <- reactive({
        # For fixed data sets, ignore input_value
        if (is.null(input$dataset) && length(data_extract_spec) < 2) {
          data_extract_spec[[1]]$dataname
          # For data set selectors, return NULL if NULL
        } else {
          input$dataset
        }
      })

      filter_and_select_reactive <- reactive({
        if (is.null(dataname())) {
          NULL
        } else {
          append(
            filter_and_select[[dataname()]](),
            list(
              dataname = dataname(),
              internal_id = gsub("^.*-(.+)$", "\\1", session$ns(NULL)), # parent module id
              keys = keys[[dataname()]]
            )
          )
        }
      })
      filter_and_select_reactive
    }
  )
}

#' Creates a named list of `data_extract_srv` output
#'
#' @description `r lifecycle::badge("experimental")`
#' `data_extract_multiple_srv` loops over the list of `data_extract` given and
#' runs `data_extract_srv` for each one returning a list of reactive objects.
#' This is suitable as input for [data_merge_srv()].
#'
#' @inheritParams data_extract_srv
#' @param data_extract (named `list` of `data_extract_spec` objects) the list `data_extract_spec` objects.
#'   The names of the elements in the list need to correspond to the `ids` passed to `data_extract_ui`.
#'   See example for details.
#'
#' @return reactive named list containing outputs from [data_extract_srv()]. Output list
#' names are the same as `data_extract` input argument.
#'
#' @export
#'
#' @examples
#' library(shiny)
#' ADSL <- data.frame(
#'   STUDYID = "A",
#'   USUBJID = LETTERS[1:10],
#'   SEX = rep(c("F", "M"), 5),
#'   AGE = rpois(10, 30),
#'   BMRKR1 = rlnorm(10)
#' )
#'
#' datasets <- teal.slice::init_filtered_data(
#'   list(ADSL = list(dataset = ADSL, keys = c("STUDYID", "USUBJID"), parent = character(0))),
#'   join_keys = teal.data::join_keys(
#'     teal.data::join_key("ADSL", "ADSL", c("USUBJID", "STUDYID"))
#'   ),
#'   cdisc = TRUE
#' )
#'
#' xvar_extract <- data_extract_spec(
#'   dataname = "ADSL",
#'   filter = filter_spec(vars = "SEX", choices = c("F", "M"), selected = "F"),
#'   select = select_spec(
#'     label = "Select variable:",
#'     choices = variable_choices(ADSL, c("AGE", "BMRKR1")),
#'     selected = "AGE",
#'     multiple = TRUE,
#'     fixed = FALSE
#'   )
#' )
#'
#' yvar_extract <- data_extract_spec(
#'   dataname = "ADSL",
#'   select = select_spec(
#'     label = "Select variable:",
#'     choices = variable_choices(ADSL, c("AGE", "BMRKR1")),
#'     selected = "BMRKR1",
#'     multiple = TRUE,
#'     fixed = FALSE
#'   )
#' )
#'
#' app <- shinyApp(
#'   ui = fluidPage(
#'     teal.widgets::standard_layout(
#'       output = verbatimTextOutput("out1"),
#'       encoding = tagList(
#'         data_extract_ui(id = "xvar", label = "Select x-var", xvar_extract),
#'         data_extract_ui(id = "yvar", label = "Select y-var", yvar_extract),
#'       )
#'     )
#'   ),
#'   server = function(input, output, session) {
#'     list_of_reactive_inputs <- data_extract_multiple_srv(
#'       # names of the list corresponding to data_extract_ui ids
#'       list(xvar = xvar_extract, yvar = yvar_extract),
#'       datasets
#'     )
#'     output$out1 <- renderPrint({
#'       lapply(list_of_reactive_inputs(), function(x) x())
#'     })
#'   }
#' )
#' \dontrun{
#' runApp(app)
#' }
data_extract_multiple_srv <- function(data_extract, datasets, ...) {
  checkmate::assert_list(data_extract, names = "named")
  lapply(data_extract, function(x) {
    if (is.list(x) && !inherits(x, "data_extract_spec")) {
      checkmate::assert_list(x, "data_extract_spec")
    }
  })
  checkmate::assert_multi_class(datasets, classes = c("FilteredData", "list"))
  UseMethod("data_extract_multiple_srv", datasets)
}

#' @rdname data_extract_multiple_srv
#' @export
data_extract_multiple_srv.FilteredData <- function(data_extract, datasets, ...) {
  checkmate::assert_class(datasets, classes = "FilteredData")
  logger::log_trace(
    "data_extract_multiple_srv.filteredData initialized with dataset: { paste(datasets$datanames(), collapse = ', ') }."
  )

  data_list <- sapply(X = datasets$datanames(), simplify = FALSE, FUN = function(x) {
    reactive(datasets$get_data(dataname = x, filtered = TRUE))
  })

  join_keys <- datasets$get_join_keys()
  data_extract_multiple_srv(data_extract = data_extract, datasets = data_list, join_keys = join_keys)
}

#' @rdname data_extract_multiple_srv
#' @param join_keys (`JoinKeys` or `NULL`) of join keys per dataset in `datasets`.
#' @export
data_extract_multiple_srv.list <- function(data_extract, datasets, join_keys = NULL, ...) {
  checkmate::assert_list(datasets, types = c("reactive", "data.frame"), names = "named")
  checkmate::assert_class(join_keys, "JoinKeys", null.ok = TRUE)

  logger::log_trace(
    "data_extract_multiple_srv.list initialized with dataset: { paste(names(datasets), collapse = ', ') }."
  )

  data_extract <- Filter(Negate(is.null), data_extract)
  reactive({
    sapply(
      X = names(data_extract),
      simplify = FALSE,
      USE.NAMES = TRUE,
      function(x) {
        data_extract_srv(
          id = x,
          data_extract_spec = data_extract[[x]],
          datasets = datasets,
          join_keys = join_keys
        )
      }
    )
  })
}
