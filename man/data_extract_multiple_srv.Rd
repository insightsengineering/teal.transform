% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data_extract_module.R
\name{data_extract_multiple_srv}
\alias{data_extract_multiple_srv}
\alias{data_extract_multiple_srv.FilteredData}
\alias{data_extract_multiple_srv.list}
\title{Creates a named list of \code{data_extract_srv} output}
\usage{
data_extract_multiple_srv(data_extract, datasets, ...)

\method{data_extract_multiple_srv}{FilteredData}(data_extract, datasets, ...)

\method{data_extract_multiple_srv}{list}(data_extract, datasets, join_keys = NULL, ...)
}
\arguments{
\item{data_extract}{(named \code{list} of \code{data_extract_spec} objects) the list \code{data_extract_spec} objects.
The names of the elements in the list need to correspond to the \code{ids} passed to \code{data_extract_ui}.
See example for details.}

\item{datasets}{(\code{FilteredData} or \code{list} of \code{reactive} or non-\code{reactive} \code{data.frame})\cr
object containing data either in the form of \link[teal.slice:FilteredData]{teal.slice::FilteredData} or as a list of \code{data.frame}.
When passing a list of non-reactive \code{data.frame}s, they are converted to reactive \code{data.frame}s internally.
When passing a list of reactive or non-reactive \code{data.frame}s, the argument \code{join_keys} is required also.}

\item{...}{an additional argument \code{keys} is required when \code{datasets} is a list of \code{data.frame}.
It shall contain the keys per dataset in \code{datasets}.}

\item{join_keys}{(named \code{list}) of join keys per dataset in \code{datasets}.}
}
\value{
reactive named list containing outputs from \code{\link[=data_extract_srv]{data_extract_srv()}}. Output list
names are the same as \code{data_extract} input argument.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}
\code{data_extract_multiple_srv} loops over the list of \code{data_extract} given and
runs \code{data_extract_srv} for each one returning a list of reactive objects.
This is suitable as input for \code{\link[=data_merge_srv]{data_merge_srv()}}.
}
\examples{
library(shiny)
ADSL <- data.frame(
  STUDYID = "A",
  USUBJID = LETTERS[1:10],
  SEX = rep(c("F", "M"), 5),
  AGE = rpois(10, 30),
  BMRKR1 = rlnorm(10)
)

datasets <- teal.slice::init_filtered_data(
  list(ADSL = list(dataset = ADSL, keys = c("STUDYID", "USUBJID"), parent = character(0))),
  cdisc = TRUE
)

xvar_extract <- data_extract_spec(
  dataname = "ADSL",
  filter = filter_spec(vars = "SEX", choices = c("F", "M"), selected = "F"),
  select = select_spec(
    label = "Select variable:",
    choices = variable_choices(ADSL, c("AGE", "BMRKR1")),
    selected = "AGE",
    multiple = TRUE,
    fixed = FALSE
  )
)

yvar_extract <- data_extract_spec(
  dataname = "ADSL",
  select = select_spec(
    label = "Select variable:",
    choices = variable_choices(ADSL, c("AGE", "BMRKR1")),
    selected = "BMRKR1",
    multiple = TRUE,
    fixed = FALSE
  )
)

app <- shinyApp(
  ui = fluidPage(
    teal.widgets::standard_layout(
      output = verbatimTextOutput("out1"),
      encoding = tagList(
        data_extract_ui(id = "xvar", label = "Select x-var", xvar_extract),
        data_extract_ui(id = "yvar", label = "Select y-var", yvar_extract),
      )
    )
  ),
  server = function(input, output, session) {
    list_of_reactive_inputs <- data_extract_multiple_srv(
      # names of the list corresponding to data_extract_ui ids
      list(xvar = xvar_extract, yvar = yvar_extract),
      datasets
    )
    output$out1 <- renderPrint({
      lapply(list_of_reactive_inputs(), function(x) x())
    })
  }
)
\dontrun{
runApp(app)
}
}
