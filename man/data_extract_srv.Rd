% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data_extract_module.R
\name{data_extract_srv}
\alias{data_extract_srv}
\alias{data_extract_srv.FilteredData}
\alias{data_extract_srv.list}
\title{Extraction of the selector(s) details}
\usage{
data_extract_srv(id, datasets, data_extract_spec, ...)

\method{data_extract_srv}{FilteredData}(id, datasets, data_extract_spec, ...)

\method{data_extract_srv}{list}(id, datasets, data_extract_spec, keys, ...)
}
\arguments{
\item{id}{An ID string that corresponds with the ID used to call the module's
UI function.}

\item{datasets}{(\code{FilteredData} or \code{list} of \code{reactive} or non-\code{reactive} \code{data.frame})\cr
object containing data either in the form of \link[teal.slice:FilteredData]{teal.slice::FilteredData} or as a list of \code{data.frame}.
When passing a list of non-reactive \code{data.frame}s, they are converted to reactive \code{data.frame}s internally.
When passing a list of reactive or non-reactive \code{data.frame}s, the argument \code{keys} is required also}

\item{data_extract_spec}{(\code{data_extract_spec} or a list of \code{data_extract_spec})\cr
A list of data filter and select information constructed by \link{data_extract_spec}.}

\item{...}{an additional argument \code{keys} is required when \code{datasets} is a list of \code{data.frame}.
It shall contain the keys per dataset in \code{datasets}.}

\item{keys}{(\code{list}) of keys per dataset in \code{datasets}}
}
\value{
A reactive \code{list} containing following fields:

\itemize{
\item{\code{filters}: }{A list with the information on the filters that are applied to the data set.}
\item{\code{select}: }{The variables that are selected from the dataset.}
\item{\code{always_selected}: }{The column names from the data set that should always be selected.}
\item{\code{reshape}: }{Whether reshape long to wide should be applied or not.}
\item{\code{dataname}: }{The name of the data set.}
\item{\code{internal_id}: }{The \code{id} of the corresponding shiny input element.}
\item{\code{keys}: }{The names of the columns that can be used to merge the data set.}
}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#stable}{\figure{lifecycle-stable.svg}{options: alt='[Stable]'}}}{\strong{[Stable]}}
Extracting details of the selection(s) in \link{data_extract_ui} elements.
}
\examples{
library(shiny)

ADSL <- data.frame(
  STUDYID = "A",
  USUBJID = LETTERS[1:10],
  SEX = rep(c("F", "M"), 5),
  AGE = rpois(10, 30),
  BMRKR1 = rlnorm(10)
)
datasets <- teal.slice::init_filtered_data(
  list(ADSL = list(dataset = ADSL, keys = c("STUDYID", "USUBJID"), parent = character(0))),
  cdisc = TRUE
)

data_list <- sapply(X = datasets$datanames(), simplify = FALSE, FUN = function(x) {
  reactive(datasets$get_data(dataname = x, filtered = FALSE))
})

key_list <- sapply(X = datasets$datanames(), simplify = FALSE, FUN = function(x) {
  isolate(datasets$get_keys(dataname = x))
})

adsl_extract <- data_extract_spec(
  dataname = "ADSL",
  filter = filter_spec(vars = "SEX", choices = c("F", "M"), selected = "F"),
  select = select_spec(
    label = "Select variable:",
    choices = variable_choices(ADSL, c("AGE", "BMRKR1")),
    selected = "AGE",
    multiple = TRUE,
    fixed = FALSE
  )
)

app <- shinyApp(
  ui = fluidPage(
    teal.widgets::standard_layout(
      output = verbatimTextOutput("out1"),
      encoding = tagList(
        data_extract_ui(
          id = "adsl_var",
          label = "ADSL selection",
          data_extract_spec = adsl_extract
        )
      )
    )
  ),
  server = function(input, output, session) {
    # using a `FilteredData` object as input to `datasets`
    adsl_reactive_input <- data_extract_srv(
      id = "adsl_var",
      datasets = datasets,
      data_extract_spec = adsl_extract
    )
    # using a list of reactive `data.frame` as input to `datasets`
    # adsl_reactive_input <- data_extract_srv(
    #   id = "adsl_var",
    #   datasets = data_list,
    #   data_extract_spec = adsl_extract,
    #   keys = key_list
    # )
    output$out1 <- renderPrint({
      print(adsl_reactive_input())
    })
  }
)
\dontrun{
runApp(app)
}

}
\references{
\link{data_extract_srv}
}
