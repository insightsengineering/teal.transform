% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/0-module_picks.R
\name{.resolve}
\alias{.resolve}
\title{Resolve downstream after selected changes}
\usage{
.resolve(selected, slot_name, picks_resolved, old_picks, data)
}
\arguments{
\item{selected}{(\code{vector}) rather \code{character}, or \code{factor}. \code{numeric(2)} for \code{values()} based on numeric column.}

\item{slot_name}{(\code{character(1)}) one of \code{c("datasets", "variables", "values")}}

\item{picks_resolved}{(\code{reactiveVal})}

\item{old_picks}{(\code{picks})}

\item{data}{(\code{any} asserted further in \code{resolver})}
}
\description{
@description
When i-th select input changes then
\itemize{
\item picks_resolved containing current state is being unresolved but only after the i-th element as
values are sequentially dependent. For example if variables (i=2) is selected we don't want
to unresolve (restart) dataset.
\item new value (selected) is replacing old value in current slot (i)
\item we call resolve which resolves only "unresolved" (delayed) values
\item new picks is replacing \code{reactiveValue}
Thanks to this design reactive values are triggered only once
}
}
\keyword{internal}
