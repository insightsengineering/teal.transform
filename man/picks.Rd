% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/0-picks.R
\name{picks}
\alias{picks}
\alias{datasets}
\alias{variables}
\alias{values}
\alias{col_data}
\title{Choices/selected settings}
\usage{
picks(...)

datasets(choices = tidyselect::everything(), selected = 1, fixed = NULL, ...)

variables(
  choices = tidyselect::everything(),
  selected = 1,
  multiple = NULL,
  fixed = NULL,
  ordered = FALSE,
  ...
)

values(
  choices = tidyselect::everything(),
  selected = tidyselect::everything(),
  multiple = TRUE,
  fixed = NULL,
  ...
)

col_data(choices = tidyselect::everything(), selected = 1, multiple = FALSE)
}
\arguments{
\item{...}{additional arguments delivered to \code{pickerInput}}

\item{choices}{(\code{\link[tidyselect:language]{tidyselect::language}} or \code{character})
Available values to choose.}

\item{selected}{(\code{\link[tidyselect:language]{tidyselect::language}} or \code{character})
Choices to be selected.}

\item{fixed}{(\code{logical(1)}) selection will be fixed and not possible to change interactively.}

\item{multiple}{(\code{logical(1)}) if more than one selection is possible.}

\item{ordered}{(\code{logical(1)}) if the selected should follow the selection order. If \code{FALSE}
\code{selected} returned from \code{srv_module_input()} would be ordered according to order in \code{choices}.}
}
\description{
Define choices and default selection for variables. \code{picks} allows app-developer to specify
\code{datasets}, \code{variables} and \code{values} to be selected by app-user during Shiny session.
Functions are based on the idea of \code{choices/selected} where app-developer provides \code{choices}
and what is \code{selected} by default. App-user though changes \code{selected} interactively in
\code{\link{picks_module}}
}
\section{\code{tidyselect} support}{
Both \code{choices} and \code{selected} parameters support \code{tidyselect} syntax, enabling dynamic
and flexible variable selection patterns. This allows choices to be determined at runtime
based on data characteristics rather than hardcoded values.
\subsection{Using tidyselect for \code{choices}}{

When \code{choices} uses tidyselect, the available options are determined dynamically based on
the selected dataset's structure:
\itemize{
\item \code{tidyselect::everything()} - All variables/datasets
\item \code{tidyselect::starts_with("prefix")} - Variables starting with a prefix
\item \code{tidyselect::ends_with("suffix")} - Variables ending with a suffix
\item \code{tidyselect::contains("pattern")} - Variables containing a pattern
\item \code{tidyselect::matches("regex")} - Variables matching a regular expression
\item \code{tidyselect::where(predicate)} - Variables/datasets satisfying a predicate function
\item \code{tidyselect::all_of(vars)} - All specified variables (error if missing)
\item \code{tidyselect::any_of(vars)} - Any specified variables (silent if missing)
\item Range selectors like \code{Sepal.Length:Petal.Width} - Variables between two positions
}
}

\subsection{Using tidyselect for \code{selected}}{

The \code{selected} parameter can use:
\itemize{
\item Numeric indices (e.g., \code{1}, \code{1:3}, \code{c(1, 3, 5)}) - Select by position
\item Character vectors (e.g., \code{"Species"}, \code{c("mpg", "cyl")}) - Select by name
\item \code{tidyselect::everything()} - Select all available choices
\item Other tidyselect helpers as needed
}

\strong{Warning:} Using explicit character values for \code{selected} with dynamic \code{choices} may
cause issues if the selected values are not present in the dynamically determined choices.
Prefer using numeric indices (e.g., \code{1} for first variable) when \code{choices} is dynamic.
}
}

\section{Structure and element dependencies}{
The \code{picks()} function creates a hierarchical structure where elements depend on their
predecessors, enabling cascading reactive updates during Shiny sessions.
\subsection{Element hierarchy}{

A \code{picks} object must follow this order:
\enumerate{
\item \strong{\code{datasets()}} - to select a dataset. Always the first element (required).
\item \strong{\code{variables()}} - To select columns from the chosen dataset.
\item \strong{\code{values()}} - To select specific values from the chosen variable(s).
}

Each element's choices are evaluated within the context of its predecessor's selection.
}

\subsection{How dependencies work}{
\itemize{
\item \strong{Single dataset}: When \code{datasets(choices = "iris")} specifies one dataset, the
\code{variables()} choices are evaluated against that dataset's columns.
\item \strong{Multiple datasets}: When \code{datasets(choices = c("iris", "mtcars"))} allows multiple
options, \code{variables()} choices are re-evaluated each time the user selects a different
dataset. This creates a reactive dependency where variable choices update automatically.
\item \strong{Dynamic datasets}: When using \code{datasets(choices = tidyselect::where(is.data.frame))},
all available data frames are discovered at runtime, and variable choices adapt to
whichever dataset the user selects.
\item \strong{Variable to values}: Similarly, \code{values()} choices are evaluated based on the
selected variable(s), allowing users to filter specific levels or values.
}
}

\subsection{Best practices}{
\itemize{
\item Always start with \code{datasets()} - this is enforced by validation
\item Use dynamic \code{choices} in \code{variables()} when working with multiple datasets to ensure
compatibility across different data structures
\item Prefer \code{tidyselect::everything()} or \code{tidyselect::where()} predicates for flexible
variable selection that works across datasets with different schemas
\item Use numeric indices for \code{selected} when \code{choices} are dynamic to avoid referencing
variables that may not exist in all datasets
}
}

\subsection{Example: Three-level hierarchy}{

\if{html}{\out{<div class="sourceCode r">}}\preformatted{picks(
  datasets(choices = c("iris", "mtcars"), selected = "iris"),
  variables(choices = tidyselect::where(is.numeric), selected = 1),
  values(choices = tidyselect::everything(), selected = 1:10)
)
}\if{html}{\out{</div>}}

In this example:
\itemize{
\item User first selects a dataset (iris or mtcars)
\item Variable choices update to show only numeric columns from selected dataset
\item After selecting a variable, value choices show all unique values from that column
}
}
}

\examples{
# Select columns from iris dataset using range selector
picks(
  datasets(choices = "iris"),
  variables(choices = Sepal.Length:Petal.Width, selected = 1)
)

# Single variable selection from iris dataset
picks(
  datasets(choices = "iris", selected = "iris"),
  variables(choices = c("Sepal.Length", "Sepal.Width"), selected = "Sepal.Length", multiple = FALSE)
)

# Dynamic selection: any variable from iris, first selected by default
picks(
  datasets(choices = "iris", selected = "iris"),
  variables(choices = tidyselect::everything(), selected = 1, multiple = FALSE)
)

# Multiple dataset choices: variable choices will update when dataset changes
picks(
  datasets(choices = c("iris", "mtcars"), selected = "iris"),
  variables(choices = tidyselect::everything(), selected = 1, multiple = FALSE)
)

# Select from any dataset, filter by numeric variables
picks(
  datasets(choices = c("iris", "mtcars"), selected = 1),
  variables(choices = tidyselect::where(is.numeric), selected = 1)
)

# Fully dynamic: auto-discover datasets and variables
picks(
  datasets(choices = tidyselect::where(is.data.frame), selected = 1),
  variables(choices = tidyselect::everything(), selected = 1, multiple = FALSE)
)

# Select categorical variables with length constraints
picks(
  datasets(choices = tidyselect::everything(), selected = 1),
  variables(choices = is_categorical(min.len = 2, max.len = 15), selected = 1:2)
)

}
